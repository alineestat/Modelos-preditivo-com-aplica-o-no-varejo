# -*- coding: utf-8 -*-
"""Modelagem Prophet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19Nt2KYlG7MT9_v5EfGqwDC9x7W2KNbV9

### Bibliografias utilizadas 

* https://facebook.github.io/prophet/docs/seasonality,_holiday_effects,_and_regressors.html
* https://erico-coutojr.medium.com/modelagem-com-prophet-9b96b81bec0
* https://www.viniboscoa.dev/blog/prophet-prevendo-o-futuro-em-series-temporais
* https://www.viniboscoa.dev/blog/prophet-prevendo-o-futuro-em-series-temporais
* https://towardsdatascience.com/prophet-in-a-loop-a875516ef2f9
"""

# Commented out IPython magic to ensure Python compatibility.
#@markdown Carregando pacotes

import pandas as pd
import matplotlib.pyplot as plt
from prophet import Prophet
import numpy as np
import seaborn as sns

from statsmodels.regression.linear_model import OLS
from statsmodels.stats.stattools import durbin_watson

from sklearn.pipeline import Pipeline
from sklearn import metrics
from sklearn import linear_model
from sklearn import model_selection
from sklearn.linear_model import LinearRegression

import matplotlib.pyplot as plt

from sklearn.preprocessing import scale


# %matplotlib inline
import scipy as sp
import statsmodels.formula.api as sm
import statsmodels.api as sm

from scipy import stats

import statsmodels.api as sm

from math import sqrt
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

def mean_absolute_percentage_error(y_true, y_pred): 
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    return np.mean(np.abs((y_true - y_pred) / y_true))

pd.options.display.max_rows = 999
pd.set_option("display.float_format", lambda x: "%.2f" %x)



import plotly.express as px
import plotly.graph_objects as go

import datetime as dt

from sklearn.model_selection import train_test_split

"""## <center> Modelagem com Prophet <center>"""

#@markdown ####Leitura e tratamento base de dados
dados = pd.read_excel("/content/drive/MyDrive/Modelos Preditivos/Modelagem Matriz/Unidade Matriz/DadosLojaCosmeticos.xlsx")
colunas = ['dia', 'mês', 'ano', 'Dia_da_semana', 'Num_Semana_mes', 'feriados', 'pagamento', 'Vale']
for i in range(len(colunas)):
  dados[colunas[i]] = dados[colunas[i]].astype(int)
dados = dados[dados['Data'] < '2021-04-01']

#@markdown Base Treino(Variável a ser predita)
dados = dados[dados['Data'] > '2018-12-31']	
df = dados[['Data', 'Vendas']].set_index('Data').sort_index()
# transformando o dataframe para o formato exigido pelo Prophet
df_treino = df.reset_index().rename(columns={'Data': 'ds', 'Vendas':'y'})

fig, ax = plt.subplots(figsize=(8,5))
df.plot(ax=ax)

#@markdown Modelagem Prophet, separação treino e teste
train_set = df_treino.iloc[:-274]
test_set = df_treino[-274:]


model_diario = Prophet(weekly_seasonality=True, yearly_seasonality=True, changepoint_prior_scale=0.01)
model_diario.add_country_holidays(country_name='BR')
model_diario.fit(train_set)

y_pred = model_diario.predict(test_set)
model_diario.plot(y_pred)

print('Base de Teste MAE: {}'.format(metrics.mean_absolute_error(test_set['y'].values, y_pred['yhat'].values)))
print('Base de Teste RMSE: {}'.format(metrics.mean_squared_error(test_set['y'].values, y_pred['yhat'].values, squared=False)))

y_pred.set_index('ds')['yhat'].plot(color='red')
test_set.set_index('ds')['y'].plot(color='green')

BaseTeste = test_set.set_index('ds')['y'].reset_index()
ValorPredito = y_pred.set_index('ds')['yhat'].reset_index()
AnaliseErro = BaseTeste.merge(ValorPredito, on=['ds'], how='left')

AnaliseErro_longo = pd.melt(AnaliseErro, ['ds'],var_name='variavel', value_name='valores')
AnaliseErro_longo = AnaliseErro_longo.replace(['y', 'yhat'], ['Teste', 'Predito'])

import plotly.express as px

df = px.data.stocks()
fig = px.line(AnaliseErro_longo, x='ds', y='valores', color='variavel',  title='Análise do valor predito com a base de teste', labels={'ds': 'Data', 'valores': 'Vendas (R$)'},color_discrete_sequence=px.colors.qualitative.T10, template='plotly_white')
fig.show()

proximos_30dias = model_diario.make_future_dataframe(periods=30, freq='D')
previsao = model_diario.predict(proximos_30dias)
previsao.tail()
model_diario.plot(previsao, xlabel='Data', ylabel='Vendas')


from prophet.diagnostics import cross_validation, performance_metrics
from prophet.plot import plot_cross_validation_metric

df_cv = cross_validation(model_diario, horizon= '30 D', parallel='processes',)

df_pm = performance_metrics(df_cv)
print(df_pm.head(10), "\n")
plot_cross_validation_metric(df_cv, metric='mape', figsize=(20,8));

components_diario = model_diario.plot_components(y_pred)
components_diario

df_cv = cross_validation(model_diario, horizon= '30 D', parallel='processes',)

regression_report = performance_metrics(df_cv)
print(regression_report.head(10), "\n")
plot_cross_validation_metric(df_cv, metric='mape', figsize=(20,8));
fig = plot_cross_validation_metric(df_cv, metric='rmse')